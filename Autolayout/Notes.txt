NOTES

Autolayout great for handling labels - automatically truncating them and adjusting containing views sizes…



- Slide 1 (UILabels)

* UILabels take up minimum required space
* Set up constraints so a superview expands depending on its content (labels in this case)

Labels width = 200
Top label has higher priority
Bottom label limited to 2 lines

Green view present because of padding between labels (which are 0 height at beginning)



- Slide 2 (Compression resistance)

* Control priorities of labels using compression resistance
* So labels nicely aligned, not centred use >=, rather than = to bottom of superview



- Slide 3 (Content hugging)

* Mostly only adjust this when compiler complains about ambiguity
* Need to tell it which label will expand so it can work out sizes
* Give the label you want to expand first a lower hugging priority should sort it out

Blue label - content hugging priority > leading/trailing constraints
Red label is the opposite


- Slide 4 (Floating below multiple items) DELETE ???

* Have >= constraints from purple view to both labels
* Add = constraints from purple view to both labels with lower priority (999) so compiler doesn’t complain when it has to break 1
* Labels constrained to each other with red label having higher horizontal resistance so blue compresses first, with a minimum width


- Slide 5 (Collection views)

* Dynamic cell sizes achieved using prototype cells
* Create one cell in memory - the prototype
* In size method, set a width or height constraint and fill it with the content for the appropriate index
* Use auto layout to calculate the appropriate size using systemLayoutSizeFittingSize
* PORTRAIT - We’ve set the width constraint and allowed the label to fill the cell, determining its height
* LANDSCAPE - Set a height constraint and now the width is determined by the label


- Slide 6 (Programmatically editing constraints)

* Programatically add constraints using the visual formatting language
* Hitting “Do it!” will pin the red view to the blue view - making it expand to fill whatever size it is
* Just briefly mentioning this - you can also set priorities, widths, heights etc… Look it up if your interested!
* Our general use case is adding nibs as subviews which automatically expand to fill their superviews
* Show UIView+ALAutoLayout category
* MUST HAVE translatesAutoresizingMaskIntoConstraints = NO to work!!!

* Can have NSLayoutConstraints as IBOutlets. 
* This means we can then grab a handle on the constraints set up in the storyboard/nibs and edit their constants
* Its not possible to edit priorities at the moment - not sure why as this would be very handy
* Instead we’ve had to remove constraints and re-add them


- Slide 7 (Layout guides)


* Adds a default margin to the left and right, and accounts for status bar/nav bar if present at top.
* In some cases we want stuff to go under these (e.g. collection views scroll underneath).
* To achieve this you have to go to Editor -> Pin -> Superview, rather than dragging and clicking
* We never use the default layout margins - would add our own if we wanted!


- Slide 8 (Animation)

* Pretty easy - Hooked up constraints as IBOutlets
* Change the constant then call [view layoutIfNeeded] within an animation block…


AVAILABLE ON GITHUB!

TODO
Animate transitions